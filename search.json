[{"title":"How to use hexo","url":"/2022/02/10/How-to-use-hexo/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start·\nCreate a new post·\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server·\n$ hexo server\nMore info: Server\nGenerate static files·\n$ hexo generate\nMore info: Generating\nDeploy to remote sites·\n$ hexo deploy\nMore info: Deployment\n"},{"title":"It's my Hello,World!","url":"/2023/11/17/My-Hello-World/","content":"这是我的第一篇博客，作为“程序员”的我，理应叫他&quot;Hello,World!&quot;\n(其实我不太喜欢“程序员”这个称呼，因为总感觉它带着一些刻板印象在里面。)\nIntroduce myself·\n第一篇也也不知道说些什么，就随便唠叨唠叨了。\n那就先介绍一下自己。个人目前是在武汉做LLVM编译器开发，目前主要的工作是做编译优化。当初因为很喜欢计算机底层知识，所以选择了这个方向。可能由于国内做编译器的很少，所以同行竞争压力比较小，加上我们的老板和总监之前都是常年在国外创业和工作，所以工作氛围很轻松，而且工作时间是真的弹性965。\n但是工作压力还是有的，主要是因为编译器软件过于庞大，计算机底层知识牵涉过多，所以有时候举步维艰。所以这也是我花费周末时间搭这个博客的一点原因，想借助这个博客来记录自己的学习。当然其实更多的是兴趣使然，不然我是不可能凌晨熬夜还在看这个前端代码的。\n工作五个月，从最开始接触linux指令，跑测试，整理数据，到开始做code size相关的优化（主要是outline相关），现在由于公司要用picolibc库开发，所以最近都在和picolibc打交道，所以也接触到了很多链接器相关的东西。我的工作其实说起来很无聊，就是测试，对比，阅读LLVM源码，在源码基础上做优化，但我很喜欢我的工作，可能本身对计算机底层的兴趣使我不会那么厌烦。工作中有很多很难的东西，比如要去阅读上千上万行的源码，虽然LLVM已经有十多年的时间了，但是能参考的资料真的不是很多，而且几乎没有中文，只能硬着头皮去看英文文档。遇到特别难的东西，其实真的也会很暴躁。😦\n结果就是，在技术方面，我真的成长了许多，但现在仍然还是个菜鸡。\n\nAbout my life·\n我也很喜欢我的生活，也有很多想做的事情。\n曾经刚来武汉的一段时间，我非常暴躁，大概是因为一个人来到一座城市，没有亲人朋友的孤独感。每天打开房门，面对的就是一个黑咕隆咚的地方，好像要被吞进去，打开灯，当然仍旧是走之前的老样子，没人陪伴孤独的样子。\n现在倒是好多了，或许是因为我放下了一些执念？又或许是我看了一些书？who knows，总之真的在变好了，无论是面对的生活，还是在情绪上。希望以后会越来越好。\nHappy ending·\n总之，搭这个博客的目的，主要就是为了记录自己的生活和学习。这里也算是我自己的小天地了。\n","tags":["Hello,Wolrd!"]},{"title":"sched-model-draft","url":"/2025/05/16/sched-model-draft/","content":"Scheduling Models 1 – In-Order Pipeline and Pipeline Stalls.·\nFramework·\n\nin-order pipeline and pipeline stalls. (this blog)\nwhat we need in scheduling-model and how gcc and llvm represent it.\nwrite a scheduling-model.\nadjusting your scheduling-model for better performance.\nout-of-order docs recommendation.\n\nExtended in-order pipeline·\nExtended EX stage pipeline·\n\n我不想在这里讨论基本的五级顺序流水线概念，你可以在任何一本介绍计算机体系结构的书上找到相关的内容，所以我会假设你已经了解基本的顺序流水线知识、流水线冒险（结构冒险、数据冒险、控制冒险）、数据前推，如果你对提到的任何关键词有疑问，请先补充相关的知识 😉\n\nflowchart LR\n    IF[IF]\n    ID[ID]\n    EX[EX]\n    MEM[MEM]\n    WB[WB]\n\n    IF --&gt; ID\n    ID --&gt; EX\n    EX --&gt; MEM\n    MEM --&gt; WB\n如上图，基本的五级流水线（取指，译码，执行，访存，写回）由于做了简化，并没有暴露其中的细节。从图中看起来所有的执行单元被抽象成一个 EX stage，而真实的 CPU 流水线不仅要处理基本的整数运算，还需要处理浮点运算以及它们各自的加减乘除，所以一个完整的 EX stage 至少会包括 ALU 单元运算，乘法除法器运算单元，浮点加减运算单元，浮点乘除运算单元。\n\n假设我们有一个可以处理各种整数运算，浮点加减乘除运算的流水线，从黑盒子的角度来看，它可能长成下图这个样子。\nflowchart LR\n    IF[IF]\n    ID[ID]\n    INT_OP[Integer Unit]\n    FP_ADD[FP Add/Sub]\n    FP_MUL[FP Mul]\n    FP_DIV[FP DIV]\n    MUL[MUL/DIV]\n    MEM[MEM]\n    WB[WB]\n\n    IF --&gt;| | ID\n    ID --&gt;| | MUL\n    ID --&gt;| | FP_DIV\n    ID --&gt;| | INT_OP\n    ID --&gt;| | FP_ADD\n    ID --&gt;| | FP_MUL\n    MUL --&gt;| | MEM\n    INT_OP --&gt;| | MEM\n    FP_ADD --&gt;| | MEM\n    FP_MUL --&gt;| | MEM\n    FP_DIV --&gt;| | MEM\n    MEM --&gt;| | WB\n\n不同硬件实现不同，可能有些流水线会把一些功能单元做合并或拆分，比如将 MUL 和 DIV 分开，分别负责整数乘法和除法。\n\n假设我们现在有这样一段汇编代码，\nadd    a0, a1  --&gt; integer unitmul    a2, a3  --&gt; mul/divfp_mul a4, a5  --&gt; fp mulfp_div a6, a7  --&gt; fp div\n当每条指令走过 ID 阶段以后，会进入各自的功能单元执行，互不干扰。\nPipelined or Not-Pipelined·\n像大部分简单的 ALU 指令，比如加减法指令，通常只需要一个周期就能够完成，但由于存在长周期指令，比如，乘法指令，除法指令，由于其本身硬件实现的复杂性，所以基本上不可能一个在周期内完成（除非你压缩 CPU 的频率，让其一个周期的时间变长，但这没有意义），所以实际上每个功能单元占用的周期数是不同的。\n假设目前我们所有的功能单元同一时间只能执行一条指令，也就是说，当进入一条指令以后，就不能再进入第二条使用相同功能单元的指令了。当出现如下顺序的汇编时，\nmul a0, a1mul a2, a3\n如果 mul 指令不能在一个周期完成执行，下一条 mul 就会进入在 MUL/DIV 功能单元之前被阻塞住，也就是出现了流水线暂停的行为。\n上述对 MUL/DIV 功能单元的描述，意思就是说，这个功能单元是非流水线化的（Not-Pipelined）。\n显然这种流水线是非常慢的，会出现大量因为功能单元被占用导致的流水线暂停，所以这里我们可以引入流水线化（Pipelined）的功能单元来进行加速，允许多个需要同一功能单元的指令同时进行。\nflowchart LR\n    IF[IF]\n    ID[ID]\n    INT_OP[Integer Unit]\n    FP_ADD0[FP Add/Sub Stage 0]\n    FP_ADD1[FP Add/Sub Stage 1]\n    FP_ADD2[FP Add/Sub Stage 2]\n    FP_MUL0[FP Mul Stage 0]\n    FP_MUL1[FP Mul Stage 1]\n    FP_MUL2[FP Mul Stage 2]\n    FP_MUL3[FP Mul Stage 3]\n    FP_DIV[FP DIV]\n    MUL0[MUL/DIV Stage 0]\n    MUL1[MUL/DIV Stage 1]\n    MUL2[MUL/DIV Stage 2]\n    MEM[MEM]\n    WB[WB]\n\n    IF --&gt;| | ID\n    ID --&gt;| | MUL0\n    ID --&gt;| | FP_DIV\n    ID --&gt;| | INT_OP\n    ID --&gt;| | FP_ADD0\n    ID --&gt;| | FP_MUL0\n    INT_OP --&gt;| | MEM\n    MUL2 --&gt;| | MEM\n    FP_ADD2 --&gt;| | MEM\n    FP_MUL3 --&gt;| | MEM\n    FP_DIV --&gt;| | MEM\n    MEM --&gt;| | WB\n\n    MUL0 --&gt; MUL1 \n    MUL1 --&gt; MUL2\n\n    FP_ADD0 --&gt; FP_ADD1\n    FP_ADD1 --&gt; FP_ADD2\n\n    FP_MUL0 --&gt; FP_MUL1\n    FP_MUL1 --&gt; FP_MUL2\n    FP_MUL2 --&gt; FP_MUL3\n为了解决上述性能瓶颈，我们将 MUL/DIV 单元流水线化至三级：\n\nStage 0：对操作数进行部分积预处理；\nStage 1：计算部分积；\nStage 2：生成最终结果并写入目标寄存器。\n\n\n这里只是举个例子，真实的情况大概率与我所说的不同，这里只是帮助理解如何进行功能单元的流水线化，具体乘法器到底是如何实现，要去阅读相关资料。\n\n在满载状态下，该流水线每个周期可以接受一条新的乘除法指令。虽然每条指令仍然需要 3 个周期才能完成，但由于各阶段可并发运行，总体吞吐率显著提升。\n在图中，FP Mul 单元，Mul/Div 单元以及 FP Add/Sub 单元均已被流水线化，该流水线可以同时执行四条浮点乘法指令，三条整数乘除法指令，三条浮点加减法指令，而 FP DIV由于没有流水线化，同一时刻只能有一条指令位于该功能单元内。\n\n这里 Integer Unit也是流水线化的，因为本身就用于执行单周期指令。\n\n当再次出现如下顺序的汇编时，流水线将不会因为资源占用导致暂停了。\nmul a0, a1mul a2, a3\n\n\n大部分功能单元都是流水线化的，但是像 FP Div 这种使用频率很少的功能单元，即使做成非流水线化，通常情况下很少会导致流水线暂停。（本身使用FP Div功能单元的指令就比较少，就算出现了多条使用该功能单元的指令，调度器也不会将它们排在一起。）因此，将使用频率很少的功能单元做成非流水线化的，不仅可以减少芯片流水线复杂度，也不会有明显的负面影响。\n这里把功能单元拆成多个 stages 是为了帮助理解，实际的流水线图不会这么画，一个功能单元是否是流水线化的也需要参考对应的白皮书文档。（很多流水线的实际信息都是需要从白皮书中获取的。）\n\n\nReal Pipeline·\n让我们来看一个真实的流水线图，这是晶心科技 Andes-D45 的流水线图。\n\n  \n  \n    Andes-D45 Pipeline (From \n    \n      andestech.com\n    \n    )\n  \n\n对应的流水线简化图如下，\nflowchart LR\n    %% Issue Paths\n    Issue0[Issue Path 0]\n    Issue1[Issue Path 1]\n\n    %% Pipelines\n    ALU0[ALU0]\n    ALU1[ALU1]\n    LDST[AGU + LD/ST]\n    FP[FP Pipeline]\n    MULDIV[MUL/DIV Pipeline]\n    DSP[DSP Pipeline]\n\n    %% Connections\n    Issue0 --&gt; ALU0\n    Issue0 --&gt; ALU1\n    Issue0 --&gt; LDST\n    Issue0 --&gt; FP\n    Issue0 --&gt; MULDIV\n    Issue0 --&gt; DSP\nD45 由于是双发的流水线，一个周期会发射两条指令，考虑到 ALU 指令是最频繁的，为了可以同时双发两条 ALU 指令，它这里设置了两条 ALU 通路，也就是说，当出现下面两条汇编指令同时发射时，它们可以分别占用两条 ALU 通路，而不会导致流水线暂停。（可以想到，如果只有一条 ALU 通路的话，那么这里两条 add 指令就没法同时发射了，因为会有资源冲突，流水线会暂停。）\nadd a0, a1  --&gt; slot 0 -- use ALU0add a2, a3  --&gt; slot 1 -- use ALU1\nD45 的流水线是非常简单的，没有什么过多需要描述的地方。\n\n\nD45 的 ALU 还有一个特殊的地方，它将 ALU stages 划分为两个 stages，EX stage 和 LX stage（L 意味着 Later），这里设计的意图，可能是为了减少数据冲突导致的暂停。这个并不是主要要讨论的问题。\nDSP 单元是为了执行 Andes RISCV-P Extension 的特殊指令。\n\n\n另一个是 Sifive-P600 的流水线，它是一个乱序 4 发射的流水线，看起来可能稍微复杂一点，\n\n从图上看，可能会感觉功能单元这么多又这么复杂，但其实不然，这是一个很简单的 pipeline，我们先将乱序以及一些Cache，prefetchr，分支预测部分剖除，会得到下面这样的一个 pipeline 图。\nflowchart LR\n    %% Issue paths\n    Issue0[Issue Path 0]\n    Issue1[Issue Path 1]\n    Issue2[Issue Path 2]\n    Issue3[Issue Path 3]\n\n    %% ALU Pipelines\n    ALU_FULL[ALU + MUL + DIV + I2F]\n    ALU_ONLY[ALU]\n    BR0[BR]\n    BR1[BR]\n\n    %% LD/SD Pipelines\n    LDST0[AGU + LD/ST]\n    LDST1[AGU + LD/ST]\n\n    %% FP Pipelines\n    FP0[FP: FMAC + FADD + FMUL + I2F]\n    FP1[FP: FMAC + FADD + FMUL + FDIV]\n\n    %% Vector Pipelines\n    VEC0[Vector: ALU + DIV]\n    VEC1[Vector: ALU + V2S]\n\n    %% Connections from Issue paths\n    Issue0 --&gt; ALU_FULL\n    Issue0 --&gt; ALU_ONLY\n    Issue0 --&gt; BR0\n    Issue0 --&gt; BR1\n\n    Issue0 --&gt; LDST0\n    Issue0 --&gt; LDST1\n\n    Issue0 --&gt; FP0\n    Issue0 --&gt; FP1\n\n    Issue0 --&gt; VEC0\n    Issue0 --&gt; VEC1\n\n功能单元的名字和功能不重要，对调度来说，都只是功能单元。\n\nPipeline Stalls·\n本文前面说了这么多，就是为了铺垫这个东西 😉\n\n\npipeline 暂停包括很多内容，常说的数据冲突，结构冲突导致的暂停是其中一大部分，也是调度器主要解决的问题。\n\nThe **cycles stalled in the front-end** are a waste because that means that the Front-End does not feed the Back End with micro-operations. This can mean that you have misses in the Instruction cache, or complex instructions that are not already decoded in the micro-op cache. Just-in-time compiled code usually expresses this behavior.The **cycles stalled in the back-end** are a waste because the CPU has to wait for resources (usually memory) or to finish long latency instructions (e.g. transcedentals - sqrt, reciprocals, divisions, etc.).\t\t--from stackoverflow(https://stackoverflow.com/questions/22165299/what-are-stalled-cycles-frontend-and-stalled-cycles-backend-in-perf-stat-resul)\n\n这里不提及控制冒险，它并不是调度器所能解决的问题\n\n\nReferences·\n\n计算机体系结构：量化研究方法（第6版）附录 C\n\n","tags":["instruction scheduling"]}]